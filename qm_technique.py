# -*- coding: utf-8 -*-
"""QM Technique.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11bQ7vyxV7X8ZIM18v8F7OYZp6haCWmP5
"""

import itertools

# Function to get minterms from user input
def get_minterms():
    minterms = input("Enter the minterms separated by commas: ")  # Read minterms from user
    minterms = minterms.replace(" ", "")  # Remove any spaces from the input
    minterms = [int(x) for x in minterms.split(',')]  # Convert input string to a list of integers
    return minterms

# Function to convert a decimal number to a binary string with a fixed length
def binary_representation(n, variables):
    return format(n, '0{}b'.format(variables))  # Format the number to binary with leading zeros

# Function to count the number of '1's in a binary string
def count_ones(binary):
    return binary.count('1')  # Count occurrences of '1' in the binary string

# Function to find prime implicants using the Quine-McCluskey algorithm
def find_prime_implicants(minterms, variables):
    # Group minterms based on the number of '1's in their binary representation
    groups = {}
    for minterm in minterms:
        binary = binary_representation(minterm, variables)
        ones_count = count_ones(binary)
        if ones_count not in groups:
            groups[ones_count] = []
        groups[ones_count].append(binary)

    marked = set()  # Set to keep track of minterms that have been marked as part of an implicant
    prime_implicants = set()  # Set to store prime implicants
    while groups:
        new_groups = {}
        grouped_pairs = set()  # Set to store new implicants formed by combining existing ones
        keys = sorted(groups.keys())  # Sort group keys to ensure proper pairing

        # Combine minterms from adjacent groups to form new implicants
        for i in range(len(keys) - 1):
            group1 = keys[i]
            group2 = keys[i + 1]
            for a in groups[group1]:
                for b in groups[group2]:
                    diff = [idx for idx, (x, y) in enumerate(
                        zip(a, b)) if x != y]
                    if len(diff) == 1:  # Check if the binary strings differ by only one bit
                        new_binary = a[:diff[0]] + '-' + a[diff[0] + 1:]  # Create a new implicant by replacing differing bit with '-'
                        if new_binary not in new_groups:
                            new_groups.setdefault(
                                group1, []).append(new_binary)
                        marked.add(a)
                        marked.add(b)
                        grouped_pairs.add(new_binary)

        # Update prime implicants with those that were not marked
        prime_implicants.update(
            set(itertools.chain.from_iterable(groups.values())) - marked)
        groups = new_groups  # Move to the next level of groups

    return prime_implicants

# Function to create a chart of prime implicants vs. minterms they cover
def get_prime_implicants_chart(prime_implicants, minterms):
    chart = {}
    for prime in prime_implicants:
        chart[prime] = []
        for minterm in minterms:
            # Check if the minterm is covered by the prime implicant
            if all(prime[i] == '-' or prime[i] == bit for i, bit in enumerate(binary_representation(minterm, len(prime)))):
                chart[prime].append(minterm)
    return chart

# Function to select essential prime implicants
def select_essential_prime_implicants(chart):
    essential_prime_implicants = set()
    all_minterms = set(itertools.chain.from_iterable(chart.values()))

    while all_minterms:
        # Find the prime implicant that covers the maximum number of remaining minterms
        max_cover = max(chart, key=lambda k: len(set(chart[k]) & all_minterms))
        essential_prime_implicants.add(max_cover)
        all_minterms -= set(chart[max_cover])  # Remove covered minterms from the set
        chart = {k: v for k, v in chart.items(
        ) if k not in essential_prime_implicants}  # Remove selected implicants from the chart

    return essential_prime_implicants

# Function to convert an implicant to a Boolean expression
def implicant_to_expression(implicant):
    variables = ['A', 'B', 'C', 'D', 'E']  # Define variable names
    term = []
    for i, char in enumerate(implicant):
        if char == '1':
            term.append(variables[i])  # Add variable if the bit is '1'
        elif char == '0':
            term.append(f"{variables[i]}'")  # Add negated variable if the bit is '0'
    return ''.join(term)  # Join all parts to form the expression

# Main function to run the Quine-McCluskey algorithm
def quine_mccluskey(minterms, variables):
    prime_implicants = find_prime_implicants(minterms, variables)
    prime_implicants_chart = get_prime_implicants_chart(
        prime_implicants, minterms)
    essential_prime_implicants = select_essential_prime_implicants(
        prime_implicants_chart)

    # Generate the minimized Boolean expression
    minimized_expression = ' + '.join(implicant_to_expression(implicant)
                                      for implicant in essential_prime_implicants)
    return essential_prime_implicants, minimized_expression

# Main entry point of the script
def main():
    minterms = get_minterms()  # Get minterms from user
    variables = 5  # Number of variables (assuming 5 for this example)
    essential_prime_implicants, minimized_expression = quine_mccluskey(
        minterms, variables)

    print("Essential Prime Implicants:")
    for epi in essential_prime_implicants:
        print(epi)  # Print each essential prime implicant
    print("\nMinimized Boolean Expression:")
    print(minimized_expression)  # Print the minimized Boolean expression

# Run the main function if the script is executed
if __name__ == "__main__":
    main()